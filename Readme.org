#+TITLE: Emacs configuration

#+STARTUP: overview

* Introduction

This =Readme.org= file is the entry point to my Emacs configuration. It uses =org-babel= to create a literate, modular setup.

The way this works is that this =org-mode= file contains both descriptive text explaining each part of the configuration, and source code blocks that define the actual behavior. When processed by =org-babel=, the code blocks are "tangled" into a =Readme.el= file, which is then loaded by Emacs on startup.

In other words: every piece of Emacs Lisp in this file *is* the real configuration I use. Neat, right?

* Initial configuration (must be at the beginning)

** Start the Emacs server

We start the server in order to be able to use =emacsclient=.

#+begin_src emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+end_src

** Set up and initialize package manager

#+begin_src emacs-lisp
  (require 'package)
  (setq package-user-dir (expand-file-name "elpa/" user-emacs-directory))

  (setq package-archives '(("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "https://melpa.org/packages/")
                           ))

  (setq package-enable-at-startup nil)
  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

** Set up =use-package=

#+begin_src emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

* Interface tweaks

Small interface tweaks to simplify the look and feel

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (blink-cursor-mode 0)
  (show-paren-mode)
  (setq ring-bell-function 'ignore)
#+end_src

* Appearance

** Font

Set default font

*** Jetbrains Mono

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :family "JetBrains Mono" :height 150)
  (add-to-list 'default-frame-alist '(font . "JetBrains Mono 15"))
#+end_src

** Theme

*** ir-black

#+begin_src emacs-lisp
  (use-package ir-black-theme
    :ensure t
    :config
    (load-theme 'ir-black t))
#+end_src

*** Disable other themes

#+begin_src emacs-lisp
  (mapc #'disable-theme custom-enabled-themes)
  (load-theme 'ir-black t)
#+end_src

** Indentation Guides

Highlight the indentation level of programming files

#+begin_src emacs-lisp
  (use-package indent-guide
    :ensure t
    :hook ((prog-mode yaml-mode) . indent-guide-mode)
    :custom
    (indent-guide-char "â”‚")
    (indent-guide-delay 0.1)
    (indent-guide-recursive t))
#+end_src

* Configurations

** Buffer

Auto revert buffers

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

Reload file with =<f5>=

#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") 'revert-buffer)
#+end_src

** Word and line wrap

Don't allow lines to overflow the screen

#+begin_src emacs-lisp
  (setq-default truncate-lines nil)
  (setq-default word-wrap t)
#+end_src

* Editing

** Line manipulation

Move line or region up or down

#+begin_src emacs-lisp
  (defun fiachetti/move-line-or-region-up ()
    "Move current line or active region up by one line."
    (interactive)
    (if (use-region-p)
        ;; Move region
        (let* ((start (save-excursion (goto-char (region-beginning)) (line-beginning-position)))
               (end (save-excursion 
                      (goto-char (region-end))
                      ;; If at beginning of line, go to end of previous line
                      (if (bolp)
                          (max start (1- (point)))
                        (line-end-position))))
               (text (buffer-substring-no-properties start end))
               (num-lines (length (split-string text "\n"))))
          ;; Can't move up if already at first line
          (when (> start (point-min))
            ;; Delete region without adding to kill ring
            (delete-region start (min (1+ end) (point-max)))
            ;; Move up one line
            (forward-line -1)
            (beginning-of-line)
            (let ((new-start (point)))
              ;; Insert the text
              (insert text "\n")
              ;; Select the inserted region - mark at start, point at end
              (goto-char (+ new-start (length text)))
              (set-mark new-start)
              (setq deactivate-mark nil))))
      ;; Move single line
      (let ((col (current-column)))
        (when (> (line-number-at-pos) 1)
          (let* ((start (line-beginning-position))
                 (end (line-end-position))
                 (text (buffer-substring-no-properties start end)))
            (delete-region start (min (1+ end) (point-max)))
            (forward-line -1)
            (beginning-of-line)
            (insert text "\n")
            (forward-line -1)
            (move-to-column col))))))

  (defun fiachetti/move-line-or-region-down ()
    "Move current line or active region down by one line."
    (interactive)
    (if (use-region-p)
        ;; Move region
        (let* ((start (save-excursion (goto-char (region-beginning)) (line-beginning-position)))
               (end (save-excursion 
                      (goto-char (region-end))
                      ;; If at beginning of line, go to end of previous line
                      (if (bolp)
                          (max start (1- (point)))
                        (line-end-position))))
               (text (buffer-substring-no-properties start end))
               (num-lines (length (split-string text "\n"))))
          ;; Can't move down if already at last line
          (when (save-excursion (goto-char end) (< end (point-max)))
            ;; Delete region without adding to kill ring
            (delete-region start (min (1+ end) (point-max)))
            ;; Move down one line
            (forward-line 1)
            (beginning-of-line)
            (let ((new-start (point)))
              ;; Insert the text
              (insert text "\n")
              ;; Select the inserted region - mark at start, point at end
              (goto-char (+ new-start (length text)))
              (set-mark new-start)
              (setq deactivate-mark nil))))
      ;; Move single line
      (let ((col (current-column)))
        (when (save-excursion (end-of-line) (not (eobp)))
          (let* ((start (line-beginning-position))
                 (end (line-end-position))
                 (text (buffer-substring-no-properties start end)))
            (delete-region start (min (1+ end) (point-max)))
            (forward-line 1)
            (beginning-of-line)
            (insert text "\n")
            (forward-line -1)
            (move-to-column col))))))
#+end_src

* Global keybindings

** Define keybindings on the fly

Use =H-k= to define keybindings on the fly

#+begin_src emacs-lisp
  (global-set-key (kbd "H-k") 'global-set-key)
#+end_src

** Save current buffer

Find files in the current project

#+begin_src emacs-lisp
  (global-set-key (kbd "H-s") 'save-buffer)
#+end_src

** Finding files

Find files in the current project

#+begin_src emacs-lisp
  (global-set-key (kbd "H-f") 'project-find-file)
#+end_src

** Lines

Delete the current line

#+begin_src emacs-lisp
  (global-set-key (kbd "H--") #'kill-whole-line)
#+end_src

Move line or region up or down

#+begin_src emacs-lisp
  (global-set-key (kbd "<H-S-up>") 'fiachetti/move-line-or-region-up)
  (global-set-key (kbd "<H-S-down>") 'fiachetti/move-line-or-region-down)
#+end_src

* Window movement

** Winner mode

Navigate window configuration history

#+begin_src emacs-lisp
  (winner-mode 1)
#+end_src

** Global keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "H-<left>")  'windmove-left)
  (global-set-key (kbd "H-<right>") 'windmove-right)
  (global-set-key (kbd "H-<up>")    'windmove-up)
  (global-set-key (kbd "H-<down>")  'windmove-down)

  (global-set-key (kbd "H-w") 'balance-windows)
#+end_src

* Bookmarks

#+begin_src emacs-lisp
  (global-set-key (kbd "H-0") 'bookmark-jump)
  (global-set-key (kbd "H-)") 'bookmark-set)
#+end_src

* Dired

This line enables =dired-find-alternate-file=, which allows you to open a file from dired using the =a= keybinding without being promped.

#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

* Try

Try packages on the fly without the need to install them.

Once emacs is restarted, the package goes away.

#+begin_src emacs-lisp
  (use-package try :ensure t)
#+end_src

* Which key

Discover available keybindings.

#+begin_src emacs-lisp
  (which-key-setup-side-window-bottom)

  (require 'which-key)
  (which-key-mode)
#+end_src

* Completion UI

** Vertico

Vertico provides a vertical completion UI using Emacs' built-in completion system.
It improves `completing-read` without introducing external frameworks.

#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode 1))
#+end_src

** Orderless

Orderless improves the way Emacs matches completion candidates. Instead of matching strictly from the beginning, it lets you type space-separated components in any order.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil))
#+end_src

** Consult

Consult provides a set of powerful search and navigation commands, enhancing the built-in Emacs UX.

#+begin_src emacs-lisp
  (use-package consult
    :bind
    (("C-s" . consult-line)                  ;; search in current buffer
     ("C-x b" . consult-buffer)              ;; switch buffer
     ("C-x 4 b" . consult-buffer-other-window)
     ("M-y" . consult-yank-pop)              ;; show kill ring
     ("C-c f" . consult-find)                ;; find files recursively
     ;; ("C-c g" . consult-git-grep)            ;; search in git project
     ("C-c r" . consult-ripgrep)             ;; ripgrep (needs to be installed)
     ("C-c m" . consult-imenu)))             ;; jump to symbol in buffer
#+end_src

** Marginalia

Marginalia adds annotations to minibuffer completion candidates, making them easier to understand and choose.

#+begin_src emacs-lisp
  (use-package marginalia
    :init
    (marginalia-mode))
#+end_src

* Magit

Use magit for git integration

#+begin_src emacs-lisp
  (use-package magit :ensure t)
#+end_src

** Keybindings

These are the keybindings I like to use to see my git status

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c g") 'magit-status)
  (global-set-key (kbd "C-c C-g") 'magit-status)
#+end_src

** Full screen magit-status and unfold all sections

Whenever I enter the magit status, it goes full-screen, hiding the rest of the windows

#+begin_src emacs-lisp
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows)
    (magit-section-show-level-2-all))
#+end_src

** Restore windows after quitting magit

And it restores the previous window layout once I quit

#+begin_src emacs-lisp
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+end_src

** Some custom variables

Some extra variables I like

#+begin_src emacs-lisp
  (custom-set-variables
   '(git-commit-fill-column 1000)
   '(git-commit-finish-query-functions nil)
   '(git-commit-summary-max-length 1000))
#+end_src

* Tree-sitter support

Enable tree-sitter major modes when available. This allows us to use `ruby-ts-mode`, `json-ts-mode`, etc., for better performance and parsing.

#+begin_src emacs-lisp
  (when (fboundp 'treesit-available-p)
    (setq major-mode-remap-alist
          '((ruby-mode . ruby-ts-mode)
            (json-mode . json-ts-mode)
            (js-mode . js-ts-mode)
            (css-mode . css-ts-mode)
            (html-mode . html-ts-mode)
            (yaml-mode . yaml-ts-mode))))
#+end_src

Always prefer treesit when opening files

#+begin_src emacs-lisp
  (setq treesit-font-lock-level 4)
#+end_src

* Environment

** Direnv

We load the current Ruby environment from `.envrc` files using `envrc-mode`, which integrates `direnv` into Emacs. This ensures Emacs sees the same Ruby version and gems as the terminal.

#+begin_src emacs-lisp
  (use-package envrc
    :init
    (envrc-global-mode))
#+end_src

* LSP support

We use `lsp-mode` for language server integration. Per-language configuration lives in dedicated sections below.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :custom
    (lsp-enable-symbol-highlighting t)
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-completion-provider :none)) ;; we'll add UI/completion separately
#+end_src

** LSP keybindings

#+begin_src emacs-lisp
  (with-eval-after-load 'lsp-mode
    (global-set-key (kbd "H-=") #'lsp-format-buffer))
#+end_src

* Ruby LSP

Use `ruby-lsp`, installed via the Gemfile and automatically discovered via `direnv`.

#+begin_src emacs-lisp
;; Ensure lsp-mode is installed and available
(use-package lsp-mode
  :ensure t
  :init
  ;; Register ruby-lsp for ruby-ts-mode (not always auto-registered)
  (defun my/register-ruby-lsp-client ()
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection
                       (lambda ()
                         lsp-ruby-lsp-server-command)) ; uses overridden value from .dir-locals.el
      :activation-fn (lsp-activate-on "ruby") ; activates based on language id
      :priority 1
      :server-id 'ruby-lsp
      :major-modes '(ruby-mode ruby-ts-mode))))
  :config
  (my/register-ruby-lsp-client))
#+end_src
