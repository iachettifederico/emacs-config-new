#+TITLE: Emacs configuration

#+STARTUP: overview

* Introduction

This =Readme.org= file is the entry point to my Emacs configuration. It uses =org-babel= to create a literate, modular setup.

The way this works is that this =org-mode= file contains both descriptive text explaining each part of the configuration, and source code blocks that define the actual behavior. When processed by =org-babel=, the code blocks are "tangled" into a =Readme.el= file, which is then loaded by Emacs on startup.

In other words: every piece of Emacs Lisp in this file *is* the real configuration I use. Neat, right?

* Initial configuration (must be at the beginning)

** Start the Emacs server

We start the server in order to be able to use =emacsclient=.

#+begin_src emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+end_src

** Set up and initialize package manager

#+begin_src emacs-lisp
  (require 'package)
  (setq package-user-dir (expand-file-name "elpa/" user-emacs-directory))

  (setq package-archives '(("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "https://melpa.org/packages/")
                           ))

  (setq package-enable-at-startup nil)
  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

** Set up =use-package=

#+begin_src emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

* Interface tweaks

Small interface tweaks to simplify the look and feel

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (blink-cursor-mode 0)
  (show-paren-mode)
  (setq ring-bell-function 'ignore)
#+end_src

* Appearance

** Font

*** Set default font

**** Jetbrains Mono

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :family "JetBrains Mono" :height 150)
  (add-to-list 'default-frame-alist '(font . "JetBrains Mono 15"))
#+end_src

*** Nerd icons

#+begin_src emacs-lisp
  (setq nerd-icons-font-family "FiraCode Nerd Font Mono")
#+end_src

** Theme

*** ir-black

#+begin_src emacs-lisp
  (use-package ir-black-theme
    :ensure t
    :config
    (load-theme 'ir-black t))
#+end_src

*** Disable other themes

#+begin_src emacs-lisp
  (mapc #'disable-theme custom-enabled-themes)
  (load-theme 'ir-black t)
#+end_src

** Indentation Guides

Highlight the indentation level of programming files

#+begin_src emacs-lisp
  (use-package indent-guide
    :ensure t
    :hook ((prog-mode yaml-mode) . indent-guide-mode)
    :custom
    (indent-guide-char "│")
    (indent-guide-delay 0.1)
    (indent-guide-recursive t))
#+end_src

* Configurations

** Buffer

Auto revert buffers

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

Reload file with =<f5>=

#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") 'revert-buffer)
#+end_src

** Word and line wrap

Don't allow lines to overflow the screen

#+begin_src emacs-lisp
  (setq-default truncate-lines nil)
  (setq-default word-wrap t)
#+end_src

* Editing

** Delete selection

When a region (selection) is active and you start typing, this config will replace that selection with the inserted text

#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

** Dead characters

Add support for dead characters

#+begin_src emacs-lisp
  (require 'iso-transl)
#+end_src

** Line manipulation

*** Move line or region up or down

Move line or region up

#+begin_src emacs-lisp
  (defun fiachetti/move-line-or-region-up ()
    "Move current line or active region up by one line."
    (interactive)
    (if (use-region-p)
        ;; Move region
        (let* ((start (save-excursion (goto-char (region-beginning)) (line-beginning-position)))
               (end (save-excursion
                      (goto-char (region-end))
                      ;; If at beginning of line, go to end of previous line
                      (if (bolp)
                          (max start (1- (point)))
                        (line-end-position))))
               (text (buffer-substring-no-properties start end))
               (num-lines (length (split-string text "\n"))))
          ;; Can't move up if already at first line
          (when (> start (point-min))
            ;; Delete region without adding to kill ring
            (delete-region start (min (1+ end) (point-max)))
            ;; Move up one line
            (forward-line -1)
            (beginning-of-line)
            (let ((new-start (point)))
              ;; Insert the text
              (insert text "\n")
              ;; Select the inserted region - mark at start, point at end
              (goto-char (+ new-start (length text)))
              (set-mark new-start)
              (setq deactivate-mark nil))))
      ;; Move single line
      (let ((col (current-column)))
        (when (> (line-number-at-pos) 1)
          (let* ((start (line-beginning-position))
                 (end (line-end-position))
                 (text (buffer-substring-no-properties start end)))
            (delete-region start (min (1+ end) (point-max)))
            (forward-line -1)
            (beginning-of-line)
            (insert text "\n")
            (forward-line -1)
            (move-to-column col))))))
#+end_src

Move line or region down

#+begin_src emacs-lisp
  (defun fiachetti/move-line-or-region-down ()
    "Move current line or active region down by one line."
    (interactive)
    (if (use-region-p)
        ;; Move region
        (let* ((start (save-excursion (goto-char (region-beginning)) (line-beginning-position)))
               (end (save-excursion
                      (goto-char (region-end))
                      ;; If at beginning of line, go to end of previous line
                      (if (bolp)
                          (max start (1- (point)))
                        (line-end-position))))
               (text (buffer-substring-no-properties start end))
               (num-lines (length (split-string text "\n"))))
          ;; Can't move down if already at last line
          (when (save-excursion (goto-char end) (< end (point-max)))
            ;; Delete region without adding to kill ring
            (delete-region start (min (1+ end) (point-max)))
            ;; Move down one line
            (forward-line 1)
            (beginning-of-line)
            (let ((new-start (point)))
              ;; Insert the text
              (insert text "\n")
              ;; Select the inserted region - mark at start, point at end
              (goto-char (+ new-start (length text)))
              (set-mark new-start)
              (setq deactivate-mark nil))))
      ;; Move single line
      (let ((col (current-column)))
        (when (save-excursion (end-of-line) (not (eobp)))
          (let* ((start (line-beginning-position))
                 (end (line-end-position))
                 (text (buffer-substring-no-properties start end)))
            (delete-region start (min (1+ end) (point-max)))
            (forward-line 1)
            (beginning-of-line)
            (insert text "\n")
            (forward-line -1)
            (move-to-column col))))))
#+end_src

Duplicate line

#+begin_src emacs-lisp
    ;;;###autoload
  (defun fiachetti/duplicate-line()
    (interactive)
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (open-line 1)
    (next-line 1)
    (yank))
#+end_src

* Global keybindings

** Define keybindings on the fly

Use =H-k= to define keybindings on the fly

#+begin_src emacs-lisp
  (global-set-key (kbd "H-k") 'global-set-key)
#+end_src

** Save current buffer

Find files in the current project

#+begin_src emacs-lisp
  (global-set-key (kbd "H-s") 'save-buffer)
#+end_src

** Finding files

Find files in the current project

#+begin_src emacs-lisp
  (global-set-key (kbd "H-f") 'project-find-file)
#+end_src

** Lines

Delete the current line

#+begin_src emacs-lisp
  (global-set-key (kbd "H--") #'kill-whole-line)
#+end_src

Move line or region up or down

#+begin_src emacs-lisp
  (global-set-key (kbd "<H-S-up>") 'fiachetti/move-line-or-region-up)
  (global-set-key (kbd "<H-S-down>") 'fiachetti/move-line-or-region-down)
#+end_src

Duplicate line

#+begin_src emacs-lisp
  (global-set-key (kbd "H-d") 'fiachetti/duplicate-line)
#+end_src

Join lines

#+begin_src emacs-lisp
  (global-set-key (kbd "H-j") (lambda ()
                                (interactive)
                                (join-line -1)))
#+end_src

Sort lines

#+begin_src emacs-lisp
  (global-set-key (kbd "H-l") 'sort-lines)
#+end_src

* File commands

Useful utilities for working with the current file.

** Delete the current file and buffer

#+begin_src emacs-lisp
  (defun fiachetti/delete-file-and-buffer ()
    "Delete the file visited by the current buffer, without using Git."
    (interactive)
    (let ((filename (buffer-file-name)))
      (when (and filename
                 (file-exists-p filename)
                 (yes-or-no-p (format "Really delete '%s'?" filename)))
        (delete-file filename)
        (kill-this-buffer)
        (message "Deleted %s" filename))))
#+end_src

Use =H-D d= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D d") #'fiachetti/delete-file-and-buffer)
#+end_src

** Rename current file

#+begin_src emacs-lisp
  (defun fiachetti/rename-current-file ()
    "Rename current file and buffer."
    (interactive)
    (let* ((old-name (buffer-file-name))
           (new-name (read-file-name "Rename to: " old-name)))
      (when (vc-backend old-name)
        (vc-rename-file old-name new-name))
      (rename-file old-name new-name 1)
      (set-visited-file-name new-name t t)
      (message "Renamed to %s" new-name)))
#+end_src

Use =H-D r= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D r") #'fiachetti/rename-current-file)
#+end_src

** Copy current path to clipboard

#+begin_src emacs-lisp
  (defun fiachetti/copy-file-path ()
    "Copy the current file path to the clipboard."
    (interactive)
    (let ((path (or (buffer-file-name) default-directory)))
      (kill-new path)
      (message "Copied: %s" path)))
#+end_src

Use =H-D p= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D p") #'fiachetti/copy-file-path)
#+end_src

** Copy current file name to clipboard

#+begin_src emacs-lisp
  (defun fiachetti/copy-file-name ()
    "Copy the name of the current file (without the path) to the clipboard."
    (interactive)
    (let ((name (file-name-nondirectory (or (buffer-file-name) ""))))
      (kill-new name)
      (message "Copied: %s" name)))
#+end_src

Use =H-D n= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D n") #'fiachetti/copy-file-name)
#+end_src

** Change mode permissions (=chmod=) to the current file

#+begin_src emacs-lisp
  (defun fiachetti/change-file-mode ()
    "Change the permissions (mode) of the current file."
    (interactive)
    (when-let ((file (buffer-file-name)))
      (let* ((current-mode (file-modes-symbolic file))
             (new-mode (read-string (format "chmod (was %s): " current-mode))))
        (set-file-modes file (file-modes-symbolic-to-number new-mode))
        (message "Changed mode to %s for %s" new-mode file))))
#+end_src

Use =H-D m= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D m") #'fiachetti/change-file-mode)
#+end_src

* Windows

** Movement

*** Winner mode

Navigate window configuration history

#+begin_src emacs-lisp
  (winner-mode 1)
#+end_src

**** Global keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "H-<left>")  'windmove-left)
  (global-set-key (kbd "H-<right>") 'windmove-right)
  (global-set-key (kbd "H-<up>")    'windmove-up)
  (global-set-key (kbd "H-<down>")  'windmove-down)

  (global-set-key (kbd "H-w") 'balance-windows)
#+end_src

*** Split vertically by default

#+begin_src emacs-lisp
  (setq split-height-threshold nil)
  (setq split-width-threshold 0)
#+end_src

* Buffers

** Switch to scratch buffer

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-w")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer "*scratch*")))
#+end_src

* Directories

When visiting a file whose parent directory does not exist, automatically create the directory first.

This allows opening paths like =foo/bar/baz.rb= without manually creating intermediate directories.

#+begin_src emacs-lisp
  (defun fiachetti/make-parent-directory ()
    "Create parent directory for the current file if it does not exist.

  This runs from `find-file-not-found-functions` and is safe to call
  only when `buffer-file-name` is non-nil."
    (let ((parent (file-name-directory (or buffer-file-name ""))))
      (when (and parent (not (file-exists-p parent)))
        (make-directory parent t))))

  (add-hook 'find-file-not-found-functions
            #'fiachetti/make-parent-directory)
#+end_src

* Font size customizations

** Increase and decrease font size

#+begin_src emacs-lisp
  (setq fiachetti/font-size-increment 5)

  ;;;###autoload
  (defun fiachetti/decrease-font ()
    "Decrease the font for all buffers"
    (interactive)
    (let ((old-face-attribute (face-attribute 'default :height)))
      (set-face-attribute 'default nil :height (+ old-face-attribute fiachetti/font-size-increment))))

  ;;;###autoload
  (defun fiachetti/increase-font ()
    "Increase the font for all buffers"
    (interactive)
    (let ((old-face-attribute (face-attribute 'default :height)))
      (set-face-attribute 'default nil :height (- old-face-attribute fiachetti/font-size-increment))))
#+end_src

** Key Bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "H-]") 'fiachetti/increase-font)
  (global-set-key (kbd "H-[") 'fiachetti/decrease-font)
#+end_src

* Bookmarks

#+begin_src emacs-lisp
  (global-set-key (kbd "H-0") 'bookmark-jump)
  (global-set-key (kbd "H-)") 'bookmark-set)
#+end_src

* org-mode

** Blocks

*** Custom block templates

#+begin_src emacs-lisp
  (dolist (template
           '(("-" . "src")
             ("q" . "quote")
             ("v" . "verse")
             ("r" . "src ruby")
             ("l" . "src emacs-lisp")
             ("s" . "src sh")
             ("C" . "comment")
             ("e" . "example")
             ("h" . "export html")
             ("a" . "export ascii")
             ("c" . "center")
             ("E" . "export")))
    (setf (alist-get (car template) org-structure-template-alist nil nil #'string=)
          (cdr template)))
#+end_src

** Clocking

Configure how time tracking works with org-clock.

#+begin_src emacs-lisp
  ;; Store clocks in a named drawer instead of cluttering entries
  (setq org-clock-into-drawer "CLOCKING")

  ;; Format durations as "1:30" instead of decimal hours
  (setq org-duration-format 'h:mm)

  ;; Optional: persist clocks across Emacs restarts
  ;; (setq org-clock-persist 'history)
  ;; (org-clock-persistence-insinuate)
#+end_src

** Eye candy

#+begin_src emacs-lisp
  (use-package org-modern
    :ensure t
    :hook (org-mode . org-modern-mode))
#+end_src

** Org Babel

Enable execution of source code blocks in Org files.

#+begin_src emacs-lisp
  (use-package org
    :config
    ;; Syntax highlighting in code blocks
    (setq org-src-fontify-natively t)

    ;; Enable supported languages for code blocks
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((ruby . t)
       (emacs-lisp . t)
       (org . t))))
#+end_src

** Pandoc config

*** Export dispatch options for Pandoc

#+begin_src emacs-lisp
  (use-package ox-pandoc
    :ensure t
    :after org
    :config
    (setq org-pandoc-menu-entry
          '((?h "to html5" org-pandoc-export-to-html5)
            (?H "to html5 and open" org-pandoc-export-to-html5-and-open)
            (?p "to html5-pdf" org-pandoc-export-to-html5-pdf)
            (?P "to html5-pdf and open" org-pandoc-export-to-html5-pdf-and-open)
            (?e "to epub3" org-pandoc-export-to-epub3)
            (?E "to epub3 and open" org-pandoc-export-to-epub3-and-open)
            (?m "to markdown" org-pandoc-export-to-markdown)
            (?M "to markdown and open" org-pandoc-export-to-markdown-and-open)
            (?o "to odt" org-pandoc-export-to-odt)
            (?O "to odt and open" org-pandoc-export-to-odt-and-open)
            (?r "as revealjs" org-pandoc-export-as-revealjs)
            (?R "to revealjs and open" org-pandoc-export-to-revealjs-and-open)
            (?i "to infojs" org-pandoc-export-to-infojs)
            (?I "to infojs and open" org-pandoc-export-to-infojs-and-open))))
#+end_src

** Populate org-mode shots

#+begin_src emacs-lisp
  ;;;###autoload
  (defun fiachetti/populate-org-shots (ARG)
    "Populate {{{shot(n)}}}* macros on current buffer"
    (interactive "p")
    (save-excursion
      (beginning-of-buffer)
      (kmacro-set-counter 1)
      (while (search-forward "{{{shot(" nil t)
        (kmacro-insert-counter ARG)
        (let ((start (point)))
          (search-forward-regexp "\\(,\.+)\\|)}}}\\)")
          (let ((end (match-beginning 0)))
            (delete-region start end)
            )
          ))))
#+end_src

*** Insert shot and populate

#+begin_src emacs-lisp
  ;;;###autoload
  (defun fiachetti/insert-and-populate-org-shots ()
    "Insert {{{shot()}}} and repopulate shots on buffer"
    (interactive)
    (insert "{{{shot()}}}")
    (fiachetti/populate-org-shots t))
#+end_src

** Org Export Support

#+begin_src emacs-lisp
  (use-package htmlize :ensure t)
#+end_src

* Dired

** Open with "a"

This line enables =dired-find-alternate-file=, which allows you to open a file from dired using the =a= keybinding without being promped.

#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

** Auto refresh dired, but be quiet about it

#+begin_src emacs-lisp
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (add-hook 'dired-mode-hook #'auto-revert-mode)
#+end_src

** Jump to top and bottom

#+begin_src emacs-lisp
  (defun fiachetti/dired-top ()
    "Jump to first real file in Dired."
    (interactive)
    (goto-char (point-min))
    (dired-next-line 2))

  (defun fiachetti/dired-bottom ()
    "Jump to last file in Dired."
    (interactive)
    (goto-char (point-max))
    (dired-next-line -1))

  (with-eval-after-load 'dired
    (define-key dired-mode-map [remap beginning-of-buffer] #'fiachetti/dired-top)
    (define-key dired-mode-map [remap end-of-buffer] #'fiachetti/dired-bottom))
#+end_src

** File ordering

#+begin_src emacs-lisp
  (when (executable-find "ls")
    (setq dired-listing-switches "-aBhl --group-directories-first"))
#+end_src

** Dired omit

#+begin_src emacs-lisp
  (setq-default dired-omit-files-p nil) ; Buffer-local variable

  (setq dired-omit-files "^\\.?#\\|^\\.$\\|^\\.[^\\.]")
  ;; (setq dired-omit-mode t) ; Turn on Omit mode.
  (setq dired-omit-verbose nil) ; Turn off Omit mode messages.
#+end_src

** dired-x

#+begin_src emacs-lisp
  (require 'dired-x)
#+end_src

** Hide details

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
#+end_src

** diredfl

#+begin_src emacs-lisp
  (use-package diredfl
    :hook (dired-mode . diredfl-mode)
    :config
    ;; Override default colors to match dark themes like ir-black
    (set-face-attribute 'diredfl-dir-name nil :foreground "#66d9ef" :weight 'normal)
    (set-face-attribute 'diredfl-file-name nil :foreground "#f8f8f2")
    (set-face-attribute 'diredfl-symlink nil :foreground "#fd971f" :slant 'italic)
    (set-face-attribute 'diredfl-exec-priv nil :foreground "#a6e22e")
    (set-face-attribute 'diredfl-read-priv nil :foreground "#f92672")
    (set-face-attribute 'diredfl-write-priv nil :foreground "#fd971f"))
#+end_src

** Fuzzy filtering

#+begin_src emacs-lisp
  (use-package dired-narrow
    :bind (:map dired-mode-map
                ("/" . dired-narrow)))
#+end_src

** Some eye candy

#+begin_src emacs-lisp
  (use-package nerd-icons-dired
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

* Try

Try packages on the fly without the need to install them.

Once emacs is restarted, the package goes away.

#+begin_src emacs-lisp
  (use-package try :ensure t)
#+end_src

* Which key

Discover available keybindings.

#+begin_src emacs-lisp
  (require 'which-key)

  (setq which-key-idle-delay 0.4
        which-key-max-description-length 60         ;; allow longer lines
        which-key-max-display-columns nil           ;; use as many as fit
        which-key-allow-imprecise-window-fit t      ;; don't truncate early
        which-key-sort-order 'which-key-key-order-alpha)

  (which-key-mode)
#+end_src

* Completion UI

** Vertico

Vertico provides a vertical completion UI using Emacs' built-in completion system.
It improves `completing-read` without introducing external frameworks.

#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode 1))
#+end_src

** Orderless

Orderless improves the way Emacs matches completion candidates. Instead of matching strictly from the beginning, it lets you type space-separated components in any order.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil))
#+end_src

** Consult

Consult provides a set of powerful search and navigation commands, enhancing the built-in Emacs UX.

#+begin_src emacs-lisp
  (use-package consult
    :bind
    (("C-s" . consult-line)                  ;; search in current buffer
     ("C-x b" . consult-buffer)              ;; switch buffer
     ("C-x 4 b" . consult-buffer-other-window)
     ("M-y" . consult-yank-pop)              ;; show kill ring
     ("C-c f" . consult-find)                ;; find files recursively
     ;; ("C-c g" . consult-git-grep)            ;; search in git project
     ("C-c r" . consult-ripgrep)             ;; ripgrep (needs to be installed)
     ("C-c m" . consult-imenu)))             ;; jump to symbol in buffer
#+end_src

** Marginalia

Marginalia adds annotations to minibuffer completion candidates, making them easier to understand and choose.

#+begin_src emacs-lisp
  (use-package marginalia
    :init
    (marginalia-mode))
#+end_src

** Corfu

Corfu adds a clean popup completion UI for Emacs' built-in `completion-at-point` system (CAPF).
It works well with `orderless` and `lsp-mode`.

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :custom
    (corfu-auto t)                     ;; Auto-popup completion
    (corfu-auto-delay 0.2)            ;; Slight delay before popup
    (corfu-auto-prefix 1)             ;; Start showing after 1 char
    (corfu-cycle t)                   ;; Wrap around when navigating
    (corfu-quit-no-match 'separator)  ;; Exit if no matches and you type space
    :init
    (global-corfu-mode))
#+end_src

*** Tab behaviour

=tab= will invoke completion at point unless it can indent

#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src

* Magit

Use magit for git integration

#+begin_src emacs-lisp
  (use-package magit :ensure t)
#+end_src

** Keybindings

These are the keybindings I like to use to see my git status

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c g") 'magit-status)
  (global-set-key (kbd "C-c C-g") 'magit-status)
#+end_src

** Full screen magit-status and unfold all sections

Whenever I enter the magit status, it goes full-screen, hiding the rest of the windows

#+begin_src emacs-lisp
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows)
    (magit-section-show-level-2-all))
#+end_src

** Restore windows after quitting magit

And it restores the previous window layout once I quit

#+begin_src emacs-lisp
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+end_src

** Some custom variables

Some extra variables I like

#+begin_src emacs-lisp
  (custom-set-variables
   '(git-commit-fill-column 1000)
   '(git-commit-finish-query-functions nil)
   '(git-commit-summary-max-length 1000))
#+end_src

* Tree-sitter support

Enable tree-sitter major modes when available. This allows us to use `ruby-ts-mode`, `json-ts-mode`, etc., for better performance and parsing.

#+begin_src emacs-lisp
  (when (fboundp 'treesit-available-p)
    (setq major-mode-remap-alist
          '((ruby-mode . ruby-ts-mode)
            (json-mode . json-ts-mode)
            (js-mode . js-ts-mode)
            (css-mode . css-ts-mode)
            (html-mode . html-ts-mode)
            (yaml-mode . yaml-ts-mode))))
#+end_src

Always prefer treesit when opening files

#+begin_src emacs-lisp
  (setq treesit-font-lock-level 4)
#+end_src

* Environment

** Direnv

We load the current Ruby environment from `.envrc` files using `envrc-mode`, which integrates `direnv` into Emacs. This ensures Emacs sees the same Ruby version and gems as the terminal.

#+begin_src emacs-lisp
  (use-package envrc
    :init
    (envrc-global-mode))
#+end_src

* LSP Support

Use `lsp-mode` for Language Server Protocol support. This package is responsible
for communicating with language servers — it sends file content, cursor positions,
and receives things like diagnostics, completions, and hover info.

We only configure the base layer here. Language-specific setup (like Ruby, JS, etc.)
lives in their own sections.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :hook ((ruby-mode . lsp-deferred)
           (ruby-ts-mode . lsp-deferred))
    :custom
    (lsp-enable-symbol-highlighting t)
    (lsp-completion-provider :none))
#+end_src

* Ruby LSP

Configure `ruby-lsp` as the language server for Ruby files.

We use the `ruby-lsp` gem from the project's `Gemfile`, executed via `bundle exec`.
This gives us diagnostics (including RuboCop), formatting, hover docs, jump-to-def, and more.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :config
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection '("bundle" "exec" "ruby-lsp"))
      :activation-fn (lsp-activate-on "ruby")
      :priority 1
      :server-id 'ruby-lsp
      :major-modes '(ruby-mode ruby-ts-mode))))
#+end_src

** Automatically start LSP in Ruby files

#+begin_src emacs-lisp
  (with-eval-after-load 'lsp-mode
    (add-hook 'ruby-mode #'lsp-deferred)
    (add-hook 'ruby-ts-mode #'lsp-deferred))
#+end_src

* Formatting buffers

Select the best way to format the current buffer

#+begin_src emacs-lisp
  (defun fiachetti/format-buffer ()
    "Format the current buffer using the best available method."
    (interactive)
    (cond
     ;; Use LSP formatter if available
     ((and (boundp 'lsp-mode) lsp-mode
           (fboundp 'lsp-format-buffer))
      (lsp-format-buffer))

     ;; Org-mode custom formatting
     ((derived-mode-p 'org-mode)
      (org-align-all-tags)
      ;; remove `org-align-all-tables` since it's unavailable
      (org-fill-buffer)
      (message "Formatted Org buffer."))

     ;; Fallback: smart indenting
     (t
      (fiachetti/reindent-buffer)
      (message "Reindented buffer."))))
#+end_src

Use =H-== to format the entire buffer

#+begin_src emacs-lisp
  (global-set-key (kbd "H-=") #'fiachetti/format-buffer)
#+end_src

Use =H-+= to reindent buffers

#+begin_src emacs-lisp
  (global-set-key (kbd "H-=") #'fiachetti/reindent-buffer)
#+end_src

** Reindent buffer

#+begin_src emacs-lisp
  (defun fiachetti/reindent-buffer ()
    "Clean up and indent the current buffer.

  Removes trailing whitespace, indents all lines, and converts tabs to spaces."
    (interactive)
    (save-excursion
      (delete-trailing-whitespace)
      (indent-region (point-min) (point-max))
      (untabify (point-min) (point-max))))
#+end_src

* Yaml

#+begin_src emacs-lisp
  (use-package yaml-ts-mode
    :mode ("\\.ya?ml\\'" . yaml-ts-mode))
#+end_src

* Docker

#+begin_src emacs-lisp
  (use-package dockerfile-ts-mode
    :mode ("Dockerfile\\'" . dockerfile-ts-mode))
#+end_src
