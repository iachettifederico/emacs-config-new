#+TITLE: Emacs configuration

#+STARTUP: overview

* Introduction

This =Readme.org= file is the entry point to my Emacs configuration. It uses =org-babel= to create a literate, modular setup.

The way this works is that this =org-mode= file contains both descriptive text explaining each part of the configuration, and source code blocks that define the actual behavior. When processed by =org-babel=, the code blocks are "tangled" into a =Readme.el= file, which is then loaded by Emacs on startup.

In other words: every piece of Emacs Lisp in this file *is* the real configuration I use. Neat, right?

* Initial configuration (must be at the beginning)

** Start the Emacs server

We start the server in order to be able to use =emacsclient=.

#+begin_src emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+end_src

** Set up and initialize package manager

#+begin_src emacs-lisp
  (require 'package)
  (setq package-user-dir (expand-file-name "elpa/" user-emacs-directory))

  (setq package-archives '(("gnu"       . "http://elpa.gnu.org/packages/")
                           ("melpa"     . "https://melpa.org/packages/")
                           ))

  (setq package-enable-at-startup nil)
  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

** Set up =use-package=

#+begin_src emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

* Interface tweaks

Small interface tweaks to simplify the look and feel

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (blink-cursor-mode 0)
  (show-paren-mode)
  (setq ring-bell-function 'ignore)
#+end_src

* Appearance

** Font

*** Set default font

**** Jetbrains Mono

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :family "JetBrains Mono" :height 150)
  (add-to-list 'default-frame-alist '(font . "JetBrains Mono 15"))
#+end_src

*** Nerd icons

#+begin_src emacs-lisp
  (setq nerd-icons-font-family "FiraCode Nerd Font Mono")
#+end_src

** Theme

Install doom themes and use =doom-ir-black=

#+begin_src emacs-lisp
  (use-package doom-themes
    :init
    ;; These affect how faces are generated
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)

    :config
    ;; Load ir-black explicitly
    (load-theme 'doom-ir-black t)

    ;; Optional: improve org-mode visuals slightly
    (doom-themes-org-config))
#+end_src

* Indentation

** Set default indentation level

#+begin_src emacs-lisp
  (setq         indent-tabs-mode nil) ; And force use of spaces
  (setq-default indent-tabs-mode nil)

  (setq c-basic-offset          2) ; indents 2 chars
  (setq tab-width               2) ; and 2 char wide for TAB

  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)

  (setq css-indent-offset       2)
  (setq js-indent-level         2)
  (setq coffee-tab-width        2)
  (setq typescript-indent-level 2)
#+end_src

** Indentation guides (indent-bars)

Add increasingly annoying indentation lines

#+begin_src emacs-lisp
  (use-package indent-bars
    :hook (prog-mode . indent-bars-mode)
    :init
    ;; Reset after theme loads and when new frames appear (daemon/emacsclient friendly).
    (defun fiachetti/indent-bars-safe-reset (&rest _)
      (when (featurep 'indent-bars)
        (ignore-errors (indent-bars-reset))))
    (add-hook 'after-load-theme-hook #'fiachetti/indent-bars-safe-reset)
    (add-hook 'after-make-frame-functions (lambda (_f) (fiachetti/indent-bars-safe-reset)))

    :custom
    ;; If your Emacs build is sketchy with :stipple, prefer characters.
    ;; (Recommended by the package docs as a fallback.) :contentReference[oaicite:6]{index=6}
    (indent-bars-prefer-character t)
    (indent-bars-no-stipple-char ?│)

    ;; Main color: MUST be (COLOR-OR-FACE :blend N), not a plist. :contentReference[oaicite:7]{index=7}
    ;; Start from “keyword blue vibe”, but keep blend 0 while stabilizing.
    (indent-bars-color '("#3b86d1" :blend 0.0))

    ;; Depth-based “annoyance ramp”
    ;; 1–3 acceptable blues, 4–5 louder, 6–10 obnoxious.
    ;; Use a LIST here for maximum compatibility across versions.
    (indent-bars-color-by-depth
     '(:palette
       ("#223244" "#2f6aa3" "#3b86d1"  ; 1–3 acceptable (blue)
        "#4aa3ff" "#00b7ff"            ; 4–5 annoying (bright blue/cyan)
        "#00f0ff" "#7c4dff" "#ff3df2"  ; 6–8 very annoying (cyan→purple→magenta)
        "#ffd400" "#ff3b30")))         ; 9–10 screaming (yellow→red)

    ;; Geometry
    (indent-bars-width-frac 0.12)
    (indent-bars-pad-frac 0.10)
    (indent-bars-zigzag nil)
    (indent-bars-pattern "."))
#+end_src

* Configurations

** Buffer

Auto revert buffers

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

Reload file with =<f5>=

#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") 'revert-buffer)
#+end_src

** Word and line wrap

Don't allow lines to overflow the screen

#+begin_src emacs-lisp
  (setq-default truncate-lines nil)
  (setq-default word-wrap t)
#+end_src

* Editing

** Delete selection

When a region (selection) is active and you start typing, this config will replace that selection with the inserted text

#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

** Dead characters

Add support for dead characters

#+begin_src emacs-lisp
  (require 'iso-transl)
#+end_src

** Line manipulation

*** Move line or region up or down

Move line or region up

#+begin_src emacs-lisp
  (defun fiachetti/move-line-or-region-up ()
    "Move current line or active region up by one line."
    (interactive)
    (if (use-region-p)
        ;; Move region
        (let* ((start (save-excursion (goto-char (region-beginning)) (line-beginning-position)))
               (end (save-excursion
                      (goto-char (region-end))
                      ;; If at beginning of line, go to end of previous line
                      (if (bolp)
                          (max start (1- (point)))
                        (line-end-position))))
               (text (buffer-substring-no-properties start end))
               (num-lines (length (split-string text "\n"))))
          ;; Can't move up if already at first line
          (when (> start (point-min))
            ;; Delete region without adding to kill ring
            (delete-region start (min (1+ end) (point-max)))
            ;; Move up one line
            (forward-line -1)
            (beginning-of-line)
            (let ((new-start (point)))
              ;; Insert the text
              (insert text "\n")
              ;; Select the inserted region - mark at start, point at end
              (goto-char (+ new-start (length text)))
              (set-mark new-start)
              (setq deactivate-mark nil))))
      ;; Move single line
      (let ((col (current-column)))
        (when (> (line-number-at-pos) 1)
          (let* ((start (line-beginning-position))
                 (end (line-end-position))
                 (text (buffer-substring-no-properties start end)))
            (delete-region start (min (1+ end) (point-max)))
            (forward-line -1)
            (beginning-of-line)
            (insert text "\n")
            (forward-line -1)
            (move-to-column col))))))
#+end_src

Move line or region down

#+begin_src emacs-lisp
  (defun fiachetti/move-line-or-region-down ()
    "Move current line or active region down by one line."
    (interactive)
    (if (use-region-p)
        ;; Move region
        (let* ((start (save-excursion (goto-char (region-beginning)) (line-beginning-position)))
               (end (save-excursion
                      (goto-char (region-end))
                      ;; If at beginning of line, go to end of previous line
                      (if (bolp)
                          (max start (1- (point)))
                        (line-end-position))))
               (text (buffer-substring-no-properties start end))
               (num-lines (length (split-string text "\n"))))
          ;; Can't move down if already at last line
          (when (save-excursion (goto-char end) (< end (point-max)))
            ;; Delete region without adding to kill ring
            (delete-region start (min (1+ end) (point-max)))
            ;; Move down one line
            (forward-line 1)
            (beginning-of-line)
            (let ((new-start (point)))
              ;; Insert the text
              (insert text "\n")
              ;; Select the inserted region - mark at start, point at end
              (goto-char (+ new-start (length text)))
              (set-mark new-start)
              (setq deactivate-mark nil))))
      ;; Move single line
      (let ((col (current-column)))
        (when (save-excursion (end-of-line) (not (eobp)))
          (let* ((start (line-beginning-position))
                 (end (line-end-position))
                 (text (buffer-substring-no-properties start end)))
            (delete-region start (min (1+ end) (point-max)))
            (forward-line 1)
            (beginning-of-line)
            (insert text "\n")
            (forward-line -1)
            (move-to-column col))))))
#+end_src

Duplicate line

#+begin_src emacs-lisp
    ;;;###autoload
  (defun fiachetti/duplicate-line()
    (interactive)
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (open-line 1)
    (next-line 1)
    (yank))
#+end_src

* Global keybindings

** Define keybindings on the fly

Use =H-k= to define keybindings on the fly

#+begin_src emacs-lisp
  (global-set-key (kbd "H-k") 'global-set-key)
#+end_src

** Save current buffer

Find files in the current project

#+begin_src emacs-lisp
  (global-set-key (kbd "H-s") 'save-buffer)
#+end_src

** Finding files

Find files in the current project

#+begin_src emacs-lisp
  (global-set-key (kbd "H-f") 'project-find-file)
#+end_src

** Lines

Delete the current line

#+begin_src emacs-lisp
  (global-set-key (kbd "H--") #'kill-whole-line)
#+end_src

Move line or region up or down

#+begin_src emacs-lisp
  (global-set-key (kbd "<H-S-up>") 'fiachetti/move-line-or-region-up)
  (global-set-key (kbd "<H-S-down>") 'fiachetti/move-line-or-region-down)
#+end_src

Duplicate line

#+begin_src emacs-lisp
  (global-set-key (kbd "H-d") 'fiachetti/duplicate-line)
#+end_src

Join lines

#+begin_src emacs-lisp
  (global-set-key (kbd "H-j") (lambda ()
                                (interactive)
                                (join-line -1)))
#+end_src

Sort lines

#+begin_src emacs-lisp
  (global-set-key (kbd "H-l") 'sort-lines)
#+end_src

*** Open lines above and below

Commands for opening a new line above and below the current line

#+begin_src emacs-lisp
  ;;;###autoload
  (defun fiachetti/open-line-below ()
    "Open an empty line above the current one and move."
    (interactive)
    (move-end-of-line nil)
    (newline-and-indent))

  ;;;###autoload
  (defun fiachetti/open-line-above ()
    "Open an empty line above the current one and move."
    (interactive)
    (move-beginning-of-line nil)
    (newline-and-indent)
    (forward-line -1)
    (indent-according-to-mode))
#+end_src

Bind them

#+begin_src emacs-lisp
  (global-set-key (kbd "C-<return>") 'fiachetti/open-line-below)
  (global-set-key (kbd "C-S-<return>") 'fiachetti/open-line-above)
#+end_src

* File commands

Useful utilities for working with the current file.

** Delete the current file and buffer

#+begin_src emacs-lisp
  (defun fiachetti/delete-file-and-buffer ()
    "Delete the file visited by the current buffer, without using Git."
    (interactive)
    (let ((filename (buffer-file-name)))
      (when (and filename
                 (file-exists-p filename)
                 (yes-or-no-p (format "Really delete '%s'?" filename)))
        (delete-file filename)
        (kill-this-buffer)
        (message "Deleted %s" filename))))
#+end_src

Use =H-D d= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D d") #'fiachetti/delete-file-and-buffer)
#+end_src

** Rename current file

#+begin_src emacs-lisp
  (defun fiachetti/rename-current-file ()
    "Rename current file and buffer."
    (interactive)
    (let* ((old-name (buffer-file-name))
           (new-name (read-file-name "Rename to: " old-name)))
      (when (vc-backend old-name)
        (vc-rename-file old-name new-name))
      (rename-file old-name new-name 1)
      (set-visited-file-name new-name t t)
      (message "Renamed to %s" new-name)))
#+end_src

Use =H-D r= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D r") #'fiachetti/rename-current-file)
#+end_src

** Copy current path to clipboard

#+begin_src emacs-lisp
  (defun fiachetti/copy-file-path ()
    "Copy the current file path to the clipboard."
    (interactive)
    (let ((path (or (buffer-file-name) default-directory)))
      (kill-new path)
      (message "Copied: %s" path)))
#+end_src

Use =H-D p= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D p") #'fiachetti/copy-file-path)
#+end_src

** Copy current file name to clipboard

#+begin_src emacs-lisp
  (defun fiachetti/copy-file-name ()
    "Copy the name of the current file (without the path) to the clipboard."
    (interactive)
    (let ((name (file-name-nondirectory (or (buffer-file-name) ""))))
      (kill-new name)
      (message "Copied: %s" name)))
#+end_src

Use =H-D n= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D n") #'fiachetti/copy-file-name)
#+end_src

** Change mode permissions (=chmod=) to the current file

#+begin_src emacs-lisp
  (defun fiachetti/change-file-mode ()
    "Change the permissions (mode) of the current file."
    (interactive)
    (when-let ((file (buffer-file-name)))
      (let* ((current-mode (file-modes-symbolic file))
             (new-mode (read-string (format "chmod (was %s): " current-mode))))
        (set-file-modes file (file-modes-symbolic-to-number new-mode))
        (message "Changed mode to %s for %s" new-mode file))))
#+end_src

Use =H-D m= keybinding

#+begin_src emacs-lisp
  (global-set-key (kbd "H-D m") #'fiachetti/change-file-mode)
#+end_src

* Windows

** Movement

*** Winner mode

Navigate window configuration history

#+begin_src emacs-lisp
  (winner-mode 1)
#+end_src

**** Global keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "H-<left>")  'windmove-left)
  (global-set-key (kbd "H-<right>") 'windmove-right)
  (global-set-key (kbd "H-<up>")    'windmove-up)
  (global-set-key (kbd "H-<down>")  'windmove-down)

  (global-set-key (kbd "H-w") 'balance-windows)
#+end_src

*** Split vertically by default

#+begin_src emacs-lisp
  (setq split-height-threshold nil)
  (setq split-width-threshold 0)
#+end_src

* Buffers

** Switch to scratch buffer

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-w")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer "*scratch*")))
#+end_src

* Directories

When visiting a file whose parent directory does not exist, automatically create the directory first.

This allows opening paths like =foo/bar/baz.rb= without manually creating intermediate directories.

#+begin_src emacs-lisp
  (defun fiachetti/make-parent-directory ()
    "Create parent directory for the current file if it does not exist.

  This runs from `find-file-not-found-functions` and is safe to call
  only when `buffer-file-name` is non-nil."
    (let ((parent (file-name-directory (or buffer-file-name ""))))
      (when (and parent (not (file-exists-p parent)))
        (make-directory parent t))))

  (add-hook 'find-file-not-found-functions
            #'fiachetti/make-parent-directory)
#+end_src

* Font size customizations

** Increase and decrease font size

#+begin_src emacs-lisp
  (setq fiachetti/font-size-increment 5)

  ;;;###autoload
  (defun fiachetti/decrease-font ()
    "Decrease the font for all buffers"
    (interactive)
    (let ((old-face-attribute (face-attribute 'default :height)))
      (set-face-attribute 'default nil :height (+ old-face-attribute fiachetti/font-size-increment))))

  ;;;###autoload
  (defun fiachetti/increase-font ()
    "Increase the font for all buffers"
    (interactive)
    (let ((old-face-attribute (face-attribute 'default :height)))
      (set-face-attribute 'default nil :height (- old-face-attribute fiachetti/font-size-increment))))
#+end_src

** Key Bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "H-]") 'fiachetti/increase-font)
  (global-set-key (kbd "H-[") 'fiachetti/decrease-font)
#+end_src

* Bookmarks

#+begin_src emacs-lisp
  (global-set-key (kbd "H-0") 'bookmark-jump)
  (global-set-key (kbd "H-)") 'bookmark-set)
#+end_src

* Try

Try packages on the fly without the need to install them.

Once emacs is restarted, the package goes away.

#+begin_src emacs-lisp
  (use-package try :ensure t)
#+end_src

* Which key

Discover available keybindings.

#+begin_src emacs-lisp
  (require 'which-key)

  (setq which-key-idle-delay 0.4
        which-key-max-description-length 60         ;; allow longer lines
        which-key-max-display-columns nil           ;; use as many as fit
        which-key-allow-imprecise-window-fit t      ;; don't truncate early
        which-key-sort-order 'which-key-key-order-alpha)

  (which-key-mode)
#+end_src

* Completion UI

** Vertico

Vertico provides a vertical completion UI using Emacs' built-in completion system.
It improves `completing-read` without introducing external frameworks.

#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode 1))
#+end_src

*** Vertico directory support

Add ivy-like behaviour for directories

#+begin_src emacs-lisp
  (use-package vertico-directory
    :after vertico
    :ensure nil
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

** Orderless

Orderless improves the way Emacs matches completion candidates. Instead of matching strictly from the beginning, it lets you type space-separated components in any order.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil))
#+end_src

** Consult

Consult provides a set of powerful search and navigation commands, enhancing the built-in Emacs UX.

#+begin_src emacs-lisp
  (use-package consult
    :bind
    (("C-s" . consult-line)                  ;; search in current buffer
     ("C-x b" . consult-buffer)              ;; switch buffer
     ("C-x 4 b" . consult-buffer-other-window)
     ("M-y" . consult-yank-pop)              ;; show kill ring
     ("C-c f" . consult-find)                ;; find files recursively
     ("C-c r" . consult-ripgrep)             ;; ripgrep (needs to be installed)
     ("C-c m" . consult-imenu)))             ;; jump to symbol in buffer
#+end_src

** Embark

Embark provides a contextual action menu for minibuffer candidates.
It complements Consult by allowing actions such as exporting results.

#+begin_src emacs-lisp
  (use-package embark
    :bind (("C-." . embark-act)
           ("C-;" . embark-dwim)
           ("C-h B" . embark-bindings))
    :init
    ;; Use Embark for prefix help
    (setq prefix-help-command #'embark-prefix-help-command))
#+end_src

** Embark + Consult integration

This package provides the glue between Embark and Consult,
enabling actions like exporting Consult search results.

#+begin_src emacs-lisp
  (use-package embark-consult
    :after (embark consult))
#+end_src

** Marginalia

Marginalia adds annotations to minibuffer completion candidates, making them easier to understand and choose.

#+begin_src emacs-lisp
  (use-package marginalia
    :init
    (marginalia-mode))
#+end_src

** Corfu

Corfu adds a clean popup completion UI for Emacs' built-in `completion-at-point` system (CAPF).

#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-auto t)
    (corfu-auto-delay 0.2)
    (corfu-auto-prefix 1)
    (corfu-cycle t)
    (corfu-quit-no-match 'separator)
    :init
    (global-corfu-mode))
#+end_src

*** Tab behaviour

#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src
* Dired

** Open with "a"

This line enables =dired-find-alternate-file=, which allows you to open a file from dired using the =a= keybinding without being promped.

#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

** Auto refresh dired, but be quiet about it

#+begin_src emacs-lisp
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (add-hook 'dired-mode-hook #'auto-revert-mode)
#+end_src

** Jump to top and bottom

#+begin_src emacs-lisp
  (defun fiachetti/dired-top ()
    "Jump to first real file in Dired."
    (interactive)
    (goto-char (point-min))
    (dired-next-line 2))

  (defun fiachetti/dired-bottom ()
    "Jump to last file in Dired."
    (interactive)
    (goto-char (point-max))
    (dired-next-line -1))

  (with-eval-after-load 'dired
    (define-key dired-mode-map [remap beginning-of-buffer] #'fiachetti/dired-top)
    (define-key dired-mode-map [remap end-of-buffer] #'fiachetti/dired-bottom))
#+end_src

** File ordering

#+begin_src emacs-lisp
  (when (executable-find "ls")
    (setq dired-listing-switches "-aBhl --group-directories-first"))
#+end_src

** Dired omit

#+begin_src emacs-lisp
  (setq-default dired-omit-files-p nil) ; Buffer-local variable

  (setq dired-omit-files "^\\.?#\\|^\\.$\\|^\\.[^\\.]")
  ;; (setq dired-omit-mode t) ; Turn on Omit mode.
  (setq dired-omit-verbose nil) ; Turn off Omit mode messages.
#+end_src

** dired-x

#+begin_src emacs-lisp
  (require 'dired-x)
#+end_src

** Hide details

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
#+end_src

** diredfl

#+begin_src emacs-lisp
  (use-package diredfl
    :hook (dired-mode . diredfl-mode)
    :config
    ;; Override default colors to match dark themes like ir-black
    (set-face-attribute 'diredfl-dir-name nil :foreground "#66d9ef" :weight 'normal)
    (set-face-attribute 'diredfl-file-name nil :foreground "#f8f8f2")
    (set-face-attribute 'diredfl-symlink nil :foreground "#fd971f" :slant 'italic)
    (set-face-attribute 'diredfl-exec-priv nil :foreground "#a6e22e")
    (set-face-attribute 'diredfl-read-priv nil :foreground "#f92672")
    (set-face-attribute 'diredfl-write-priv nil :foreground "#fd971f"))
#+end_src

** Fuzzy filtering

#+begin_src emacs-lisp
  (use-package dired-narrow
    :bind (:map dired-mode-map
                ("/" . dired-narrow)))
#+end_src

** Some eye candy

#+begin_src emacs-lisp
  (use-package nerd-icons-dired
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

* org-mode

** Blocks

*** Custom block templates

#+begin_src emacs-lisp
  (dolist (template
           '(("-" . "src")
             ("q" . "quote")
             ("v" . "verse")
             ("r" . "src ruby")
             ("l" . "src emacs-lisp")
             ("s" . "src sh")
             ("C" . "comment")
             ("e" . "example")
             ("h" . "export html")
             ("a" . "export ascii")
             ("c" . "center")
             ("E" . "export")))
    (setf (alist-get (car template) org-structure-template-alist nil nil #'string=)
          (cdr template)))
#+end_src

** Clocking

Configure how time tracking works with org-clock.

#+begin_src emacs-lisp
  ;; Store clocks in a named drawer instead of cluttering entries
  (setq org-clock-into-drawer "CLOCKING")

  ;; Format durations as "1:30" instead of decimal hours
  (setq org-duration-format 'h:mm)

  ;; Optional: persist clocks across Emacs restarts
  ;; (setq org-clock-persist 'history)
  ;; (org-clock-persistence-insinuate)
#+end_src

** Eye candy

#+begin_src emacs-lisp
  (use-package org-modern
    :ensure t
    :hook (org-mode . org-modern-mode))
#+end_src

** Org Babel

Enable execution of source code blocks in Org files.

#+begin_src emacs-lisp
  (use-package org
    :config
    ;; Syntax highlighting in code blocks
    (setq org-src-fontify-natively t)

    ;; Enable supported languages for code blocks
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((ruby . t)
       (emacs-lisp . t)
       (org . t))))
#+end_src

** Pandoc config

*** Export dispatch options for Pandoc

#+begin_src emacs-lisp
  (use-package ox-pandoc
    :ensure t
    :after org
    :config
    (setq org-pandoc-menu-entry
          '((?h "to html5" org-pandoc-export-to-html5)
            (?H "to html5 and open" org-pandoc-export-to-html5-and-open)
            (?p "to html5-pdf" org-pandoc-export-to-html5-pdf)
            (?P "to html5-pdf and open" org-pandoc-export-to-html5-pdf-and-open)
            (?e "to epub3" org-pandoc-export-to-epub3)
            (?E "to epub3 and open" org-pandoc-export-to-epub3-and-open)
            (?m "to markdown" org-pandoc-export-to-markdown)
            (?M "to markdown and open" org-pandoc-export-to-markdown-and-open)
            (?o "to odt" org-pandoc-export-to-odt)
            (?O "to odt and open" org-pandoc-export-to-odt-and-open)
            (?r "as revealjs" org-pandoc-export-as-revealjs)
            (?R "to revealjs and open" org-pandoc-export-to-revealjs-and-open)
            (?i "to infojs" org-pandoc-export-to-infojs)
            (?I "to infojs and open" org-pandoc-export-to-infojs-and-open))))
#+end_src

** Populate org-mode shots

#+begin_src emacs-lisp
  ;;;###autoload
  (defun fiachetti/populate-org-shots (ARG)
    "Populate {{{shot(n)}}}* macros on current buffer"
    (interactive "p")
    (save-excursion
      (beginning-of-buffer)
      (kmacro-set-counter 1)
      (while (search-forward "{{{shot(" nil t)
        (kmacro-insert-counter ARG)
        (let ((start (point)))
          (search-forward-regexp "\\(,\.+)\\|)}}}\\)")
          (let ((end (match-beginning 0)))
            (delete-region start end)
            )
          ))))
#+end_src

*** Insert shot and populate

#+begin_src emacs-lisp
  ;;;###autoload
  (defun fiachetti/insert-and-populate-org-shots ()
    "Insert {{{shot()}}} and repopulate shots on buffer"
    (interactive)
    (insert "{{{shot()}}}")
    (fiachetti/populate-org-shots t))
#+end_src

** Org Export Support

#+begin_src emacs-lisp
  (use-package htmlize :ensure t)
#+end_src

* Magit

Use magit for git integration

#+begin_src emacs-lisp
  (use-package magit :ensure t)
#+end_src

** Keybindings

These are the keybindings I like to use to see my git status

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c g") 'magit-status)
  (global-set-key (kbd "C-c C-g") 'magit-status)
#+end_src

** Full screen magit-status and unfold all sections

Whenever I enter the magit status, it goes full-screen, hiding the rest of the windows

#+begin_src emacs-lisp
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows)
    (magit-section-show-level-2-all))
#+end_src

** Restore windows after quitting magit

And it restores the previous window layout once I quit

#+begin_src emacs-lisp
  (defun magit-quit-session ()
    "Restores the previous window configuration and kills the magit buffer"
    (interactive)
    (kill-buffer)
    (jump-to-register :magit-fullscreen))
  (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
#+end_src

** Some custom variables

Some extra variables I like

#+begin_src emacs-lisp
  (custom-set-variables
   '(git-commit-fill-column 1000)
   '(git-commit-finish-query-functions nil)
   '(git-commit-summary-max-length 1000))
#+end_src

* Expand region

=expand-region= allows incremental, semantic expansion of the active
region (=symbol → expression → block → function=).

#+begin_src emacs-lisp
  (use-package expand-region
    :after treesit
    :bind (("H-e" . er/expand-region)
           ("H-E" . er/contract-region))
    :custom
    (expand-region-fast-keys-enabled nil))
#+end_src

* Multiple cursors

Multiple cursors allow performing the same edit in multiple places simultaneously.

This setup preserves existing muscle memory while keeping the configuration clean and modern.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind (("C-c a"        . mc/mark-all-like-this)
           ("C-c C-a"      . mc/edit-lines)
           ("C-M-<return>" . mc/edit-lines)

           ("H-." . mc/mark-next-like-this)
           ("H-," . mc/mark-previous-like-this)
           ("H->" . mc/skip-to-next-like-this)

           ("H-<mouse-1>" . mc/add-cursor-on-click)))
#+end_src

* String inflections

Change inflections for the current symbol

#+begin_src emacs-lisp
  (use-package string-inflection
    :bind (("H-o s" . string-inflection-underscore)        ;; snake_case
           ("H-o c" . string-inflection-camelcase)         ;; CamelCase
           ("H-o l" . string-inflection-lower-camelcase)   ;; lowerCamelCase
           ("H-o k" . string-inflection-kebab-case)        ;; kebab-case
           ("H-o u" . string-inflection-upcase)))           ;; UPPER_SNAKE_CASE
#+end_src

** Language-specific inflection cycles

In addition to explicit inflections (`H-o s`, `H-o c`, etc.), some
languages benefit from a small, predictable *cycle* that matches their
idiomatic naming conventions.

Cycling is bound to `H-O` (capital O) and is enabled *only* for languages
where it makes sense.

*** Ruby

Ruby inflections: snake_case → UPPER_SNAKE_CASE → CamelCase → snake_case

#+begin_src emacs-lisp
  (with-eval-after-load 'ruby-ts-mode
    (define-key ruby-ts-mode-map
                (kbd "H-O") #'string-inflection-ruby-style-cycle))
#+end_src

** Ruby path ↔ constant helpers

These helpers convert between Ruby filesystem-style paths and constant
namespaces.

Examples:
- abc_def/ghi_jkl  ↔  AbcDef::GhiJkl

They operate on the active region if present, otherwise on the symbol
at point.

#+begin_src emacs-lisp
  (defun fiachetti/ruby--snake-to-camel (s)
    "Convert snake_case string S to CamelCase."
    (mapconcat #'capitalize (split-string s "_") ""))

  (defun fiachetti/ruby--camel-to-snake (s)
    "Convert CamelCase string S to snake_case."
    (let ((case-fold-search nil))
      (downcase
       (replace-regexp-in-string
        "\\([a-z0-9]\\)\\([A-Z]\\)" "\\1_\\2" s))))

  (defun fiachetti/ruby-path-to-constant ()
    "Convert a Ruby-style path to a Ruby constant namespace.

  Example:
    abc_def/ghi_jkl → AbcDef::GhiJkl"
    (interactive)
    (let* ((bounds (if (use-region-p)
                       (cons (region-beginning) (region-end))
                     (bounds-of-thing-at-point 'symbol)))
           (text (and bounds
                      (buffer-substring-no-properties
                       (car bounds) (cdr bounds)))))
      (when text
        (let* ((segments (split-string text "/"))
               (camelized (mapcar #'fiachetti/ruby--snake-to-camel segments))
               (result (string-join camelized "::")))
          (delete-region (car bounds) (cdr bounds))
          (insert result)))))

  (defun fiachetti/ruby-constant-to-path ()
    "Convert a Ruby constant namespace to a Ruby-style path.

  Example:
    AbcDef::GhiJkl → abc_def/ghi_jkl"
    (interactive)
    (let* ((bounds (if (use-region-p)
                       (cons (region-beginning) (region-end))
                     (bounds-of-thing-at-point 'symbol)))
           (text (and bounds
                      (buffer-substring-no-properties
                       (car bounds) (cdr bounds)))))
      (when text
        (let* ((segments (split-string text "::"))
               (underscored (mapcar #'fiachetti/ruby--camel-to-snake segments))
               (result (string-join underscored "/")))
          (delete-region (car bounds) (cdr bounds))
          (insert result)))))

  (with-eval-after-load 'ruby-ts-mode
    (define-key ruby-ts-mode-map (kbd "H-o n") #'fiachetti/ruby-path-to-constant)
    (define-key ruby-ts-mode-map (kbd "H-o p") #'fiachetti/ruby-constant-to-path))
#+end_src
** JavaScript

JavaScript inflections: camelCase → UPPER_SNAKE_CASE → CamelCase → camelCase

#+begin_src emacs-lisp
  (with-eval-after-load 'js-ts-mode
    (define-key js-ts-mode-map
                (kbd "H-O") #'string-inflection-java-style-cycle))
#+end_src

* Edit as sudo

#+begin_src emacs-lisp
  (use-package sudo-edit :ensure t)
#+end_src

* Search and replace

This section defines a search-and-replace workflow built on top of
`consult`, `embark`, and `wgrep`.

The idea is:
- use `consult-ripgrep` for fast, interactive searching
- use Embark to *export* the current result set
- use `wgrep` to edit matches across multiple files

** Consult ripgrep

#+begin_src emacs-lisp
  (defun fiachetti/consult-ripgrep-project ()
    "Search the current project with ripgrep, seeded with symbol at point."
    (interactive)
    (consult-ripgrep
     (consult--project-root)
     (thing-at-point 'symbol t)))

  (defun fiachetti/consult-ripgrep-dir ()
    "Search the current directory with ripgrep, seeded with symbol at point."
    (interactive)
    (consult-ripgrep
     default-directory
     (thing-at-point 'symbol t)))

#+end_src

*** Global keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "H-g") #'fiachetti/consult-ripgrep-project)
  (global-set-key (kbd "H-G") #'fiachetti/consult-ripgrep-dir)
#+end_src

** Exporting results with Embark

While a `consult-ripgrep` minibuffer is active, press:

- `C-.` (`embark-act`)
- then choose **Export**

This turns the current result set into a `grep-mode` buffer containing
exactly the same matches shown by Consult.

This functionality is provided by `embark-consult`.

#+begin_src emacs-lisp
  (use-package embark-consult
    :after (embark consult))
#+end_src

** Editing matches with wgrep

Once results are exported to a `grep-mode` buffer, `wgrep` allows
editing matches directly and applying the changes back to the files.

- `C-c C-e` enters `wgrep` mode
- Saving the buffer applies the changes

#+begin_src emacs-lisp
  (use-package wgrep
    :after grep
    :bind (:map grep-mode-map
                ("C-c C-e" . wgrep-change-to-wgrep-mode))
    :config
    (setq wgrep-auto-save-buffer t))
#+end_src

* Tree-sitter support

Enable tree-sitter major modes when available. This allows us to use `ruby-ts-mode`, `json-ts-mode`, etc., for better performance and parsing.

#+begin_src emacs-lisp
  (when (fboundp 'treesit-available-p)
    (setq major-mode-remap-alist
          '((ruby-mode . ruby-ts-mode)
            (json-mode . json-ts-mode)
            (js-mode . js-ts-mode)
            (css-mode . css-ts-mode)
            (html-mode . html-ts-mode)
            (yaml-mode . yaml-ts-mode))))
#+end_src

Always prefer treesit when opening files

#+begin_src emacs-lisp
  (setq treesit-font-lock-level 4)
#+end_src

* Environment

** Direnv

We load the current Ruby environment from `.envrc` files using `envrc-mode`, which integrates `direnv` into Emacs. This ensures Emacs sees the same Ruby version and gems as the terminal.

#+begin_src emacs-lisp
  (use-package envrc
    :init
    (envrc-global-mode))
#+end_src

* LSP Support

Use `lsp-mode` for Language Server Protocol support. This package is responsible
for communicating with language servers — it sends file content, cursor positions,
and receives things like diagnostics, completions, and hover info.

We only configure the base layer here. Language-specific setup (like Ruby, JS, etc.)
lives in their own sections.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :hook ((ruby-mode . lsp-deferred)
           (ruby-ts-mode . lsp-deferred))
    :custom
    (lsp-enable-symbol-highlighting t)
    (lsp-completion-provider :none))
#+end_src

* Ruby LSP

Configure `ruby-lsp` as the language server for Ruby files.

We use the `ruby-lsp` gem from the project's `Gemfile`, executed via `bundle exec`.
This gives us diagnostics (including RuboCop), formatting, hover docs, jump-to-def, and more.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :config
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection '("bundle" "exec" "ruby-lsp"))
      :activation-fn (lsp-activate-on "ruby")
      :priority 1
      :server-id 'ruby-lsp
      :major-modes '(ruby-mode ruby-ts-mode))))
#+end_src

** Automatically start LSP in Ruby files

#+begin_src emacs-lisp
  (with-eval-after-load 'lsp-mode
    (add-hook 'ruby-mode #'lsp-deferred)
    (add-hook 'ruby-ts-mode #'lsp-deferred))
#+end_src

* Rspec

#+begin_src emacs-lisp
  (use-package rspec-mode
    :bind (
           ("H-r r"   . rspec-rerun)
           ("H-r t"   . rspec-toggle-spec-and-target)
           ("H-r v"   . rspec-verify)
           ("H-r a"   . rspec-verify-all)
           ("H-r H-a" . rspec-verify-all)
           ("H-r s"   . rspec-verify-single)
           ("H-r f"   . rspec-run-last-failed)
           )
    :ensure t)
#+end_src

* Auto close parenthesis

#+begin_src emacs-lisp
  (use-package elec-pair
    :ensure nil
    :hook (after-init . electric-pair-mode)
    :init
    ;; If you also want auto-newline between pairs sometimes, toggle this later.
    ;; (setq electric-pair-open-newline-between-pairs t)

    :config
    ;; Helpful defaults
    (setq electric-pair-preserve-balance t))
#+end_src

* Snippets

Add snippets

#+begin_src emacs-lisp
  (use-package yasnippet
    :hook ((prog-mode text-mode conf-mode) . yas-minor-mode)
    :config
    (yas-reload-all))
#+end_src

#+begin_src emacs-lisp
  ;;;###autoload
  (defun fiachetti/recompile-snippets ()
    (interactive)
    (shell-command
     (concat "rm -rf "
             user-emacs-directory
             "fiachetti/snippets/**/.yas-compiled-snippets.el*"))
    (yas/recompile-all)
    (yas/reload-all))
#+end_src

Add keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "S-<f7>") 'fiachetti/recompile-snippets)
  (global-set-key (kbd "<backtab>") 'yas-expand-from-trigger-key)
  (global-set-key (kbd "C-<tab>") 'yas-insert-snippet)
#+end_src

* Formatting buffers

Select the best way to format the current buffer

#+begin_src emacs-lisp
  (defun fiachetti/format-buffer ()
    "Format the current buffer using the best available method."
    (interactive)
    (cond
     ;; Use LSP formatter if available
     ((and (boundp 'lsp-mode) lsp-mode
           (fboundp 'lsp-format-buffer))
      (lsp-format-buffer))

     ;; Org-mode custom formatting
     ((derived-mode-p 'org-mode)
      (org-align-all-tags)
      ;; remove `org-align-all-tables` since it's unavailable
      (org-fill-buffer)
      (message "Formatted Org buffer."))

     ;; Fallback: smart indenting
     (t
      (fiachetti/reindent-buffer)
      (message "Reindented buffer."))))
#+end_src

Use =H-== to format the entire buffer

#+begin_src emacs-lisp
  (global-set-key (kbd "H-=") #'fiachetti/format-buffer)
#+end_src

Use =H-+= to reindent buffers

#+begin_src emacs-lisp
  (global-set-key (kbd "H-=") #'fiachetti/reindent-buffer)
#+end_src

** Reindent buffer

#+begin_src emacs-lisp
  (defun fiachetti/reindent-buffer ()
    "Clean up and indent the current buffer.

  Removes trailing whitespace, indents all lines, and converts tabs to spaces."
    (interactive)
    (save-excursion
      (delete-trailing-whitespace)
      (indent-region (point-min) (point-max))
      (untabify (point-min) (point-max))))
#+end_src

* Yaml

#+begin_src emacs-lisp
  (use-package yaml-ts-mode
    :mode ("\\.ya?ml\\'" . yaml-ts-mode))
#+end_src

* Docker

#+begin_src emacs-lisp
  (use-package dockerfile-ts-mode
    :mode ("Dockerfile\\'" . dockerfile-ts-mode))
#+end_src

* Extra file extensions

Add modes for some other file types

** Ruby

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("Makefile\\..*" . makefile-mode))
#+end_src

** JavaScript

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.jsx\\'" . js-ts-mode))
#+end_src
